# Comprehensive test for operators and type casts

pub let test = fn () i32 {
  # ============================================================================
  # Checked Arithmetic (Default)
  # ============================================================================
  @dbg("=== Checked Arithmetic ===\n");

  # Addition
  let add1: i32 = 10 + 20;
  let add2: i32 = -5 + 15;
  @dbg("Addition: 10+20=%d, -5+15=%d\n", add1, add2);

  # Subtraction
  let sub1: i32 = 50 - 30;
  let sub2: i32 = 10 - 25;
  @dbg("Subtraction: 50-30=%d, 10-25=%d\n", sub1, sub2);

  # Multiplication
  let mul1: i32 = 7 * 8;
  let mul2: i32 = -3 * 4;
  @dbg("Multiplication: 7*8=%d, -3*4=%d\n", mul1, mul2);

  # Division
  let div1: i32 = 100 / 5;
  let div2: i32 = -20 / 4;
  @dbg("Division: 100/5=%d, -20/4=%d\n", div1, div2);

  # Modulo
  let mod1: i32 = 17 % 5;
  let mod2: i32 = 23 % 7;
  @dbg("Modulo: 17%%5=%d, 23%%7=%d\n", mod1, mod2);

  # Unsigned arithmetic
  let uadd: u32 = 100 + 200;
  let usub: u32 = 500 - 200;
  let umul: u32 = 10 * 15;
  @dbg("Unsigned: add=%u sub=%u mul=%u\n", uadd, usub, umul);

  # ============================================================================
  # Wrapping Arithmetic
  # ============================================================================
  @dbg("\n=== Wrapping Arithmetic ===\n");

  # Wrapping addition
  let wadd: i32 = 10 +% 20;
  @dbg("Wrapping add: 10+%%20=%d\n", wadd);

  # Wrapping subtraction
  let wsub: i32 = 5 -% 10;
  @dbg("Wrapping sub: 5-%%10=%d\n", wsub);

  # Wrapping multiplication
  let wmul: i32 = 100 *% 50;
  @dbg("Wrapping mul: 100*%%50=%d\n", wmul);

  # Wrapping division
  let wdiv: i32 = 100 /% 3;
  @dbg("Wrapping div: 100/%%3=%d\n", wdiv);

  # Unsigned wrapping
  let uwrap: u32 = 1000 +% 2000;
  @dbg("Unsigned wrapping: 1000+%%2000=%u\n", uwrap);

  # ============================================================================
  # Saturating Arithmetic
  # ============================================================================
  @dbg("\n=== Saturating Arithmetic ===\n");

  # Saturating addition
  let sadd: i32 = 100 +| 200;
  @dbg("Saturating add: 100+|200=%d\n", sadd);

  # Saturating subtraction
  let ssub: i32 = 50 -| 30;
  @dbg("Saturating sub: 50-|30=%d\n", ssub);

  # Saturating multiplication
  let smul: i32 = 10 *| 5;
  @dbg("Saturating mul: 10*|5=%d\n", smul);

  # Saturating division
  let sdiv: i32 = 100 /| 4;
  @dbg("Saturating div: 100/|4=%d\n", sdiv);

  # Unsigned saturating
  let usat: u32 = 500 +| 1000;
  @dbg("Unsigned saturating: 500+|1000=%u\n", usat);

  # ============================================================================
  # Shift Operators
  # ============================================================================
  @dbg("\n=== Shift Operators ===\n");

  # Left shift
  let lshift1: i32 = 1 << 3;
  let lshift2: i32 = 5 << 2;
  @dbg("Left shift: 1<<3=%d, 5<<2=%d\n", lshift1, lshift2);

  # Right shift
  let rshift1: i32 = 32 >> 2;
  let rshift2: i32 = 100 >> 3;
  @dbg("Right shift: 32>>2=%d, 100>>3=%d\n", rshift1, rshift2);

  # Unsigned shifts
  let ulshift: u32 = 1 << 5;
  let urshift: u32 = 128 >> 3;
  @dbg("Unsigned shifts: 1<<5=%u, 128>>3=%u\n", ulshift, urshift);

  # ============================================================================
  # Comparison Operators
  # ============================================================================
  @dbg("\n=== Comparison Operators ===\n");

  # Equality
  let eq1: bool = 10 == 10;
  let eq2: bool = 5 == 7;
  @dbg("Equality: 10==10=%d, 5==7=%d\n", eq1, eq2);

  # Inequality
  let ne1: bool = 10 != 20;
  let ne2: bool = 5 != 5;
  @dbg("Inequality: 10!=20=%d, 5!=5=%d\n", ne1, ne2);

  # Less than
  let lt1: bool = 5 < 10;
  let lt2: bool = 10 < 5;
  @dbg("Less than: 5<10=%d, 10<5=%d\n", lt1, lt2);

  # Greater than
  let gt1: bool = 15 > 10;
  let gt2: bool = 5 > 10;
  @dbg("Greater than: 15>10=%d, 5>10=%d\n", gt1, gt2);

  # Less than or equal
  let le1: bool = 5 <= 10;
  let le2: bool = 10 <= 10;
  let le3: bool = 15 <= 10;
  @dbg("Less or equal: 5<=10=%d, 10<=10=%d, 15<=10=%d\n", le1, le2, le3);

  # Greater than or equal
  let ge1: bool = 15 >= 10;
  let ge2: bool = 10 >= 10;
  let ge3: bool = 5 >= 10;
  @dbg("Greater or equal: 15>=10=%d, 10>=10=%d, 5>=10=%d\n", ge1, ge2, ge3);

  # ============================================================================
  # Logical Operators
  # ============================================================================
  @dbg("\n=== Logical Operators ===\n");

  # Logical AND
  let and1: bool = true && true;
  let and2: bool = true && false;
  let and3: bool = false && false;
  @dbg("Logical AND: T&&T=%d, T&&F=%d, F&&F=%d\n", and1, and2, and3);

  # Logical OR
  let or1: bool = true || false;
  let or2: bool = false || false;
  let or3: bool = true || true;
  @dbg("Logical OR: T||F=%d, F||F=%d, T||T=%d\n", or1, or2, or3);

  # Logical NOT
  let not1: bool = !true;
  let not2: bool = !false;
  @dbg("Logical NOT: !T=%d, !F=%d\n", not1, not2);

  # Combined logical expressions
  let combined1: bool = (10 > 5) && (20 < 30);
  let combined2: bool = (5 > 10) || (15 == 15);
  @dbg("Combined: (10>5)&&(20<30)=%d, (5>10)||(15==15)=%d\n", combined1, combined2);

  # ============================================================================
  # Bitwise Operators
  # ============================================================================
  @dbg("\n=== Bitwise Operators ===\n");

  # Bitwise AND
  let band: i32 = 12 & 10;  # 1100 & 1010 = 1000 = 8
  @dbg("Bitwise AND: 12&10=%d\n", band);

  # Bitwise OR
  let bor: i32 = 12 | 10;  # 1100 | 1010 = 1110 = 14
  @dbg("Bitwise OR: 12|10=%d\n", bor);

  # Bitwise XOR
  let bxor: i32 = 12 ^ 10;  # 1100 ^ 1010 = 0110 = 6
  @dbg("Bitwise XOR: 12^10=%d\n", bxor);

  # Bitwise NOT
  let bnot1: u8 = ~0;
  let bnot2: u8 = ~255;
  @dbg("Bitwise NOT: ~0=%u, ~255=%u\n", bnot1, bnot2);

  # ============================================================================
  # Unary Operators
  # ============================================================================
  @dbg("\n=== Unary Operators ===\n");

  # Unary negation
  let neg1: i32 = -42;
  let neg2: i32 = -(-10);
  @dbg("Unary negation: -42=%d, -(-10)=%d\n", neg1, neg2);

  # Address-of and dereference
  var val: i32 = 99;
  let ptr: *i32 = &val;
  let deref: i32 = *ptr;
  @dbg("Address-of/deref: *(&val)=%d\n", deref);

  # ============================================================================
  # Type Casts
  # ============================================================================
  @dbg("\n=== Type Casts ===\n");

  # Widening casts (safe)
  let i8_val: i8 = 100;
  let i32_from_i8: i32 = i8_val as i32;
  @dbg("Widen i8->i32: %d\n", i32_from_i8);

  let u16_val: u16 = 1000;
  let u64_from_u16: u64 = u16_val as u64;
  @dbg("Widen u16->u64: %llu\n", u64_from_u16);

  # Narrowing casts (checked at runtime)
  let i32_val: i32 = 50;
  let i8_from_i32: i8 = i32_val as i8;
  @dbg("Narrow i32->i8: %d\n", i8_from_i32);

  let u64_val: u64 = 200;
  let u32_from_u64: u32 = u64_val as u32;
  @dbg("Narrow u64->u32: %u\n", u32_from_u64);

  # Signed/unsigned conversions
  let i32_pos: i32 = 42;
  let u32_from_i32: u32 = i32_pos as u32;
  @dbg("Signed->unsigned: i32(42)->u32=%u\n", u32_from_i32);

  let u32_val: u32 = 100;
  let i32_from_u32: i32 = u32_val as i32;
  @dbg("Unsigned->signed: u32(100)->i32=%d\n", i32_from_u32);

  # Same-size casts
  let i64_val: i64 = 123456;
  let i64_cast: i64 = i64_val as i64;
  @dbg("Same-size cast: i64->i64=%lld\n", i64_cast);

  # Bool casts
  let bool_val: bool = true;
  let i32_from_bool: i32 = bool_val as i32;
  @dbg("Bool->i32: true=%d\n", i32_from_bool);

  # ============================================================================
  # Complex Expressions
  # ============================================================================
  @dbg("\n=== Complex Expressions ===\n");

  # Mixed arithmetic
  let complex1: i32 = (10 + 20) * 3 - 5;
  @dbg("Mixed arithmetic: (10+20)*3-5=%d\n", complex1);

  # Chained comparisons
  let x: i32 = 15;
  let in_range: bool = (x > 10) && (x < 20);
  @dbg("Chained comparison: 10<15<20=%d\n", in_range);

  # Bitwise and arithmetic combined
  let combined_ops: i32 = (8 << 2) | (4 & 7);
  @dbg("Combined ops: (8<<2)|(4&7)=%d\n", combined_ops);

  @dbg("\n=== All Operator Tests Passed ===\n");
  return 0;
};
