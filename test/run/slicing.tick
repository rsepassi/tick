# Test arrays and slices

# Type definitions
let ArrayContainer = struct {
  ints: [4]i32,
  bytes: [8]u8,
};

pub let test = fn i32 {
  # Test arrays
  @dbg("=== Array Tests ===\n");
  let arr: [5]i32 = [10, 20, 30, 40, 50];
  @dbg("Array[0]=%d Array[2]=%d Array[4]=%d\n", arr[0], arr[2], arr[4]);

  # Array of different type
  let bytes: [4]u8 = [0, 1, 2, 3];
  @dbg("Bytes: [0]=%u [1]=%u [2]=%u [3]=%u\n", bytes[0], bytes[1], bytes[2], bytes[3]);

  # Modify array element
  var arr2: [3]i32 = [1, 2, 3];
  arr2[1] = 99;
  @dbg("Modified array: [0]=%d [1]=%d [2]=%d\n", arr2[0], arr2[1], arr2[2]);

  # Struct containing arrays
  let container: ArrayContainer = ArrayContainer @ {
    ints: [100, 200, 300, 400],
    bytes: [10, 20, 30, 40, 50, 60, 70, 80],
  };
  @dbg("Container ints[0]=%d ints[3]=%d\n", container.ints[0], container.ints[3]);
  @dbg("Container bytes[0]=%u bytes[7]=%u\n", container.bytes[0], container.bytes[7]);

  # Pointer to array
  var arr3: [3]i32 = [7, 8, 9];
  let arr_ptr: *[3]i32 = &arr3;
  @dbg("Array via pointer: [0]=%d [1]=%d [2]=%d\n",
       (*arr_ptr)[0], (*arr_ptr)[1], (*arr_ptr)[2]);

  # Address-of array element
  var arr4: [5]i32 = [100, 200, 300, 400, 500];
  let elem_ptr: *i32 = &arr4[2];
  @dbg("Address-of array[2]: value=%d\n", *elem_ptr);
  *elem_ptr = 999;
  @dbg("After pointer write: arr4[2]=%d\n", arr4[2]);

  # Test string literals and slices
  @dbg("\n=== Slice Tests ===\n");

  # String literals are now [_]u8 arrays (inferred length)
  let hello_arr: [13]u8 = "Hello, World!";
  @dbg("String array first char=%c\n", hello_arr[0]);

  # Create a slice from the string array using [:]
  let hello: []u8 = hello_arr[:];
  @dbg("String slice len=%zu\n", hello.len);
  # Access slice elements directly with clean syntax!
  @dbg("First char=%c Last char=%c\n", hello[0], hello[12]);

  # Test array slicing with ranges
  let nums: [5]i32 = [10, 20, 30, 40, 50];
  let sub: []i32 = nums[1:4];  # Should be [20, 30, 40]
  @dbg("Slice nums[1:4]: len=%zu first=%d last=%d\n", sub.len, sub[0], sub[2]);

  # Test full slice
  let full: []i32 = nums[:];
  @dbg("Full slice nums[:]: len=%zu\n", full.len);

  # Test prefix and suffix slices
  let prefix: []i32 = nums[:3];  # [10, 20, 30]
  @dbg("Prefix nums[:3]: len=%zu first=%d last=%d\n", prefix.len, prefix[0], prefix[2]);

  let suffix: []i32 = nums[2:];  # [30, 40, 50]
  @dbg("Suffix nums[2:]: len=%zu first=%d last=%d\n", suffix.len, suffix[0], suffix[2]);

  # Test re-slicing (slice from slice)
  let subsub: []i32 = sub[1:3];  # slice[1:3] from [20, 30, 40] = [30, 40]
  @dbg("Re-slice sub[1:3]: len=%zu first=%d last=%d\n", subsub.len, subsub[0], subsub[1]);

  # Test re-slicing with omitted bounds
  let resub_full: []i32 = sub[:];  # Full re-slice
  @dbg("Re-slice sub[:]: len=%zu\n", resub_full.len);

  # Test slice element assignment
  let mut_nums: [5]i32 = [1, 2, 3, 4, 5];
  let mut_slice: []i32 = mut_nums[:];
  mut_slice[0] = 99;
  mut_slice[4] = 88;
  @dbg("After slice assignment: mut_nums[0]=%d mut_nums[4]=%d\n", mut_nums[0], mut_nums[4]);

  # Test address-of slice element
  let ptr_to_elem: *i32 = &mut_slice[2];
  @dbg("Address-of slice[2]: value=%d\n", *ptr_to_elem);
  *ptr_to_elem = 77;
  @dbg("After pointer write: mut_nums[2]=%d\n", mut_nums[2]);

  # Test slice.ptr field access
  let slice_ptr: *i32 = nums[:].ptr;
  @dbg("Slice ptr access: first=%d\n", *slice_ptr);

  @dbg("\n=== All Array and Slice Tests Passed ===\n");
  return 0;
};
